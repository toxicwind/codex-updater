#!/usr/bin/env bash
# Cross-distro, modular installer/updater for OpenAI Codex CLI from source (Rust)

set -euo pipefail

# Defaults
REPO_URL_DEFAULT="https://github.com/openai/codex.git"
BRANCH_DEFAULT="main"
PREFIX_DEFAULT="$HOME/.local"

# Flags
NO_SUDO=0
FORCE_REBUILD=0
CC_OVERRIDE=""
CXX_OVERRIDE=""

# Logging
log() { printf "\033[1;34m[codex]\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[warn]\033[0m %s\n" "$*"; }
err() { printf "\033[1;31m[err]\033[0m %s\n" "$*" >&2; }

# Parse args
REPO_URL="$REPO_URL_DEFAULT"
BRANCH="$BRANCH_DEFAULT"
PREFIX="$PREFIX_DEFAULT"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --prefix)
      PREFIX="$2"
      shift 2
      ;;
    --branch)
      BRANCH="$2"
      shift 2
      ;;
    --repo)
      REPO_URL="$2"
      shift 2
      ;;
    --no-sudo)
      NO_SUDO=1
      shift
      ;;
    --force-rebuild)
      FORCE_REBUILD=1
      shift
      ;;
    --cc)
      CC_OVERRIDE="$2"
      shift 2
      ;;
    --cxx)
      CXX_OVERRIDE="$2"
      shift 2
      ;;
    -h | --help)
      cat <<'USAGE'
codex-updater [--prefix DIR] [--branch NAME] [--repo URL]
              [--no-sudo] [--force-rebuild] [--cc CC] [--cxx CXX]

Installs build deps, fetches/upgrades Codex sources, builds in release,
caches artifacts by commit, and installs the binary into <prefix>/bin.
USAGE
      exit 0
      ;;
    *)
      err "Unknown arg: $1"
      exit 2
      ;;
  esac
done

# Paths
BIN_DIR="$PREFIX/bin"
STATE_DIR="$HOME/.local/share/codex-wrapper"
DIST_DIR="$STATE_DIR/dist"
META_FILE="$STATE_DIR/build-info"
CACHE_BASE="${XDG_CACHE_HOME:-$HOME/.cache}"
SRC_BASE="$CACHE_BASE/codex-src"
SRC_DIR="$SRC_BASE/codex"
INSTALL_PATH="$BIN_DIR/codex"

# Utils
need_cmd() { command -v "$1" >/dev/null 2>&1; }
do_sudo() { if [[ $NO_SUDO -eq 0 ]]; then sudo "$@"; else "$@"; fi; }

is_wsl() {
  [[ -r /proc/version ]] && grep -qiE '(microsoft|wsl)' /proc/version
}

detect_pm() {
  if need_cmd dnf5; then
    echo dnf5
  elif need_cmd dnf; then
    echo dnf
  elif need_cmd yum; then
    echo yum
  elif need_cmd apt-get; then
    echo apt
  elif need_cmd pacman; then
    echo pacman
  elif need_cmd zypper; then
    echo zypper
  elif need_cmd apk; then
    echo apk
  elif need_cmd brew; then
    echo brew
  else
    echo unknown
  fi
}

install_build_deps() {
  local pm
  pm="$(detect_pm)"
  log "Detected package manager: $pm"

  case "$pm" in
    dnf5 | dnf)
      do_sudo "$pm" -y groupinstall "Development Tools" || true
      do_sudo "$pm" -y install gcc gcc-c++ make clang pkgconf openssl-devel git curl ca-certificates || true
      ;;
    yum)
      do_sudo yum -y groupinstall "Development Tools" || true
      do_sudo yum -y install gcc gcc-c++ make clang pkgconf openssl-devel git curl ca-certificates || true
      ;;
    apt)
      do_sudo apt-get update -y
      do_sudo apt-get install -y build-essential clang pkg-config libssl-dev git curl ca-certificates
      do_sudo update-ca-certificates || true
      ;;
    pacman)
      do_sudo pacman -Sy --noconfirm --needed base-devel clang pkgconf openssl git curl ca-certificates
      ;;
    zypper)
      do_sudo zypper refresh
      do_sudo zypper -n install -t pattern devel_basis || true
      do_sudo zypper -n install gcc gcc-c++ make clang pkgconf-pkg-config libopenssl-devel git curl ca-certificates
      ;;
    apk)
      do_sudo apk add --no-cache build-base pkgconfig openssl-dev zlib-dev git curl ca-certificates
      ;;
    brew)
      brew install llvm openssl@3 pkg-config git || true
      ;;
    *)
      warn "Unknown package manager; ensure gcc/clang, make, pkg-config, OpenSSL dev, git, and curl are installed."
      ;;
  esac

  if is_wsl; then
    log "WSL detected; proceeding with Linux bootstrap as usual."
  fi
}

ensure_rust() {
  if need_cmd cargo && need_cmd rustc; then
    log "Rust toolchain: $(rustc --version)"
  else
    log "Installing Rust via rustup (non-interactive)"
    curl -sSf https://sh.rustup.rs | sh -s -- -y
    # shellcheck disable=SC1091
    source "$HOME/.cargo/env"
  fi
  rustup toolchain install stable >/dev/null 2>&1 || true
  rustup default stable >/dev/null 2>&1 || true
  log "Using cargo: $(cargo --version)"
}

ensure_paths() {
  mkdir -p "$BIN_DIR" "$SRC_BASE"
  case ":$PATH:" in
    *":$BIN_DIR:"*) ;;
    *) warn "Prefix bin ($BIN_DIR) not in PATH; add: export PATH=\"$BIN_DIR:$PATH\"" ;;
  esac
}

ensure_state_dirs() {
  mkdir -p "$STATE_DIR" "$DIST_DIR"
}

backup_existing() {
  if [[ -x "$INSTALL_PATH" ]]; then
    local ts backup
    ts="$(date +%Y%m%d-%H%M%S)"
    backup="${INSTALL_PATH}.${ts}.bak"
    log "Existing binary detected → backup: $backup"
    cp -f "$INSTALL_PATH" "$backup"
  fi
}

resolve_cc_cxx() {
  local cc_cur="${CC:-}" cxx_cur="${CXX:-}"
  local cc="" cxx=""

  if [[ -n "$CC_OVERRIDE" ]]; then
    cc="$CC_OVERRIDE"
  elif [[ -n "$cc_cur" ]] && need_cmd "$cc_cur"; then
    cc="$cc_cur"
  elif need_cmd gcc; then
    cc="gcc"
  elif need_cmd clang; then
    cc="clang"
  fi

  if [[ -n "$CXX_OVERRIDE" ]]; then
    cxx="$CXX_OVERRIDE"
  elif [[ -n "$cxx_cur" ]] && need_cmd "$cxx_cur"; then
    cxx="$cxx_cur"
  elif need_cmd g++; then
    cxx="g++"
  elif need_cmd clang++; then
    cxx="clang++"
  fi

  if [[ -z "$cc" ]]; then
    err "No working C compiler found (checked CC env, gcc, clang)."
    exit 1
  fi
  export CC="$cc"
  [[ -n "$cxx" ]] && export CXX="$cxx"
  log "C toolchain → CC=${CC}${CXX:+ CXX=${CXX}}"
}

fetch_repo() {
  mkdir -p "$SRC_BASE"
  if [[ ! -d "$SRC_DIR/.git" ]]; then
    log "Cloning $REPO_URL → $SRC_DIR"
    git clone --depth 1 --branch "$BRANCH" "$REPO_URL" "$SRC_DIR"
  else
    log "Updating repository at $SRC_DIR"
    (cd "$SRC_DIR" && git fetch origin --tags --prune && git checkout "$BRANCH" && git pull --rebase --autostash)
  fi
}

compute_build_version() {
  local root="$1" desc ver
  desc="$(git -C "$root" describe --tags --match 'rust-v*' --abbrev=0 2>/dev/null || true)"
  if [[ -n "$desc" ]]; then
    ver="${desc#rust-v}"
    printf '%s' "$ver"
    return 0
  fi
  desc="$(git -C "$root" describe --tags --abbrev=0 2>/dev/null || true)"
  if [[ -n "$desc" ]]; then
    ver="${desc#v}"
    printf '%s' "$ver"
    return 0
  fi
  printf '%s' "0.0.0"
}

set_workspace_version() {
  local cargo_dir="$1" new_version="$2" cargo_file="$cargo_dir/Cargo.toml"
  if [[ ! -f "$cargo_file" ]]; then
    err "Cargo workspace manifest not found at $cargo_file"
    return 1
  fi
  NEW_VERSION="$new_version" python3 - "$cargo_file" <<'PY'
import os, sys
from pathlib import Path
path = Path(sys.argv[1])
version = os.environ["NEW_VERSION"]
original = path.read_text()
lines = original.splitlines()
updated = []
in_ws = False
replaced = False
for line in lines:
    stripped = line.strip()
    if stripped.startswith("["):
        in_ws = stripped == "[workspace.package]"
    if in_ws and stripped.startswith("version"):
        indent = line[: len(line) - len(line.lstrip())]
        updated.append(f'{indent}version = "{version}"')
        replaced = True
        in_ws = False
        continue
    updated.append(line)
if not replaced:
    print("Failed to update workspace version in Cargo.toml", file=sys.stderr)
    sys.exit(1)
path.write_text("\n".join(updated) + ("\n" if original.endswith("\n") else ""))
PY
}

dist_path_for_commit() {
  local commit="$1"
  printf '%s' "$DIST_DIR/codex-$commit"
}

write_metadata() {
  local commit="$1" version="$2"
  ensure_state_dirs
  {
    printf 'commit=%s\n' "$commit"
    printf 'version=%s\n' "$version"
    printf 'built_at=%s\n' "$(date +%s)"
    printf 'branch=%s\n' "$BRANCH"
    printf 'repo=%s\n' "$REPO_URL"
  } >"$META_FILE"
}

read_metadata() {
  PREV_COMMIT=""
  PREV_VERSION=""
  [[ -f "$META_FILE" ]] || return 1
  while IFS='=' read -r k v; do
    case "$k" in
      commit) PREV_COMMIT="$v" ;;
      version) PREV_VERSION="$v" ;;
    esac
  done <"$META_FILE"
  [[ -n "${PREV_COMMIT:-}" || -n "${PREV_VERSION:-}" ]]
}

build_and_install() {
  local build_dir git_root head_commit short_commit version dist_target bin_candidate
  if [[ -d "$SRC_DIR/codex-rs" ]]; then build_dir="$SRC_DIR/codex-rs"; else build_dir="$SRC_DIR"; fi
  git_root="$SRC_DIR"

  ensure_state_dirs
  read_metadata || true

  head_commit="$(git -C "$git_root" rev-parse HEAD)"
  [[ -n "$head_commit" ]] || {
    err "Unable to determine current commit hash."
    exit 1
  }
  short_commit="${head_commit:0:12}"
  version="$(compute_build_version "$git_root")"
  dist_target="$(dist_path_for_commit "$head_commit")"

  if [[ $FORCE_REBUILD -ne 1 && "${PREV_COMMIT:-}" == "$head_commit" ]]; then
    if [[ -x "$INSTALL_PATH" ]]; then
      log "No upstream changes (commit $short_commit); reusing existing binary."
      write_metadata "$head_commit" "${PREV_VERSION:-$version}"
      [[ -x "$dist_target" ]] || install -Dm0755 "$INSTALL_PATH" "$dist_target"
      ln -sfn "$dist_target" "$DIST_DIR/latest"
      return 0
    elif [[ -x "$dist_target" ]]; then
      log "Binary missing but cached artifact exists for commit $short_commit; reinstalling."
      backup_existing
      install -Dm0755 "$dist_target" "$INSTALL_PATH"
      write_metadata "$head_commit" "${PREV_VERSION:-$version}"
      ln -sfn "$dist_target" "$DIST_DIR/latest"
      return 0
    else
      log "Commit unchanged but install missing; rebuilding."
    fi
  fi

  log "Building commit $short_commit (version $version) in: $build_dir"
  (
    set -euo pipefail
    cd "$build_dir"
    set_workspace_version "$build_dir" "$version"
    trap 'git checkout -- Cargo.toml Cargo.lock >/dev/null 2>&1 || true' EXIT
    [[ $FORCE_REBUILD -eq 1 ]] && cargo clean || true
    cargo build --release
  )

  bin_candidate="$(find "$build_dir/target/release" -maxdepth 1 -type f -executable -name 'codex' | head -n1 || true)"
  [[ -n "$bin_candidate" ]] || {
    err "Build succeeded but 'codex' binary not found. Check workspace layout."
    exit 1
  }

  install -Dm0755 "$bin_candidate" "$dist_target"
  ln -sfn "$dist_target" "$DIST_DIR/latest"
  backup_existing
  install -Dm0755 "$dist_target" "$INSTALL_PATH"
  write_metadata "$head_commit" "$version"
  log "Installed → $INSTALL_PATH (commit $short_commit, version $version)"
}

verify() {
  if [[ -x "$INSTALL_PATH" ]]; then
    log "Version: $($INSTALL_PATH --version || echo 'unknown')"
    if "$INSTALL_PATH" --help >/dev/null 2>&1; then
      log "Self-test: OK"
    else
      warn "Self-test: FAIL (binary exists but --help errored)."
    fi
  else
    err "Install not found at $INSTALL_PATH"
    exit 1
  fi
}

report_path_conflicts() {
  log "PATH resolution for 'codex':"
  command -v codex >/dev/null 2>&1 && command -v codex || true
  if command -v which >/dev/null 2>&1; then which -a codex || true; fi
}

main() {
  log "Starting installer (repo=$REPO_URL, branch=$BRANCH, prefix=$PREFIX)"
  install_build_deps
  ensure_rust
  ensure_paths
  resolve_cc_cxx
  fetch_repo
  build_and_install
  verify
  report_path_conflicts
  log "Done."
}

main "$@"
