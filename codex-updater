#!/usr/bin/env bash
# Cross-distro, modular installer/updater for OpenAI Codex CLI from source (Rust)

set -euo pipefail

# Defaults
REPO_URL_DEFAULT="https://github.com/openai/codex.git"
BRANCH_DEFAULT="main"
PREFIX_DEFAULT="$HOME/.local"

# Flags
NO_SUDO=0
FORCE_REBUILD=0
CC_OVERRIDE=""
CXX_OVERRIDE=""
OPT_PRESET="${CODEX_OPT_PRESET:-balanced}"
TARGET_CPU_OVERRIDE="${CODEX_TARGET_CPU:-}"
USE_SCCACHE="${CODEX_USE_SCCACHE:-auto}"
EXTRA_RUSTFLAGS="${CODEX_EXTRA_RUSTFLAGS:-}"
CARGO_JOBS="${CODEX_CARGO_JOBS:-}"

# Logging
log() { printf "\033[1;34m[codex]\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[warn]\033[0m %s\n" "$*"; }
err() { printf "\033[1;31m[err]\033[0m %s\n" "$*" >&2; }

# Parse args
REPO_URL="$REPO_URL_DEFAULT"
BRANCH="$BRANCH_DEFAULT"
PREFIX="$PREFIX_DEFAULT"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --prefix)
      PREFIX="$2"
      shift 2
      ;;
    --branch)
      BRANCH="$2"
      shift 2
      ;;
    --repo)
      REPO_URL="$2"
      shift 2
      ;;
    --no-sudo)
      NO_SUDO=1
      shift
      ;;
    --force-rebuild)
      FORCE_REBUILD=1
      shift
      ;;
    --cc)
      CC_OVERRIDE="$2"
      shift 2
      ;;
    --cxx)
      CXX_OVERRIDE="$2"
      shift 2
      ;;
    --opt-preset)
      OPT_PRESET="$2"
      shift 2
      ;;
    --cpu-target)
      TARGET_CPU_OVERRIDE="$2"
      shift 2
      ;;
    --sccache-mode)
      USE_SCCACHE="$2"
      shift 2
      ;;
    --workspace)
      WORKSPACE_DIR="$2"
      SRC_BASE="$WORKSPACE_BUILD_DIR"
      SRC_DIR="$WORKSPACE_BUILD_DIR"
      shift 2
      ;;
    --skip-deps)
      SKIP_BUILD_DEPS=1
      shift
      ;;
    -h | --help)
      cat <<'USAGE'
codex-updater [--prefix DIR] [--branch NAME] [--repo URL]
              [--no-sudo] [--force-rebuild] [--cc CC] [--cxx CXX]
              [--opt-preset portable|balanced|native]
              [--cpu-target <rustc-target>] [--sccache-mode on|off|auto]
              [--workspace DIR] [--skip-deps]

Installs build deps, fetches/upgrades Codex sources, builds in release,
caches artifacts by commit, and installs the binary into <prefix>/bin.
Environment overrides:
  CODEX_OPT_PRESET        same as --opt-preset (default: balanced)
  CODEX_TARGET_CPU        target cpu passed to -C target-cpu
  CODEX_USE_SCCACHE       on|off|auto (default: auto)
  CODEX_EXTRA_RUSTFLAGS   appended to RUSTFLAGS
  CODEX_CARGO_JOBS        passed to CARGO_BUILD_JOBS
  CODEX_WORKSPACE         path to local codex-updater checkout to build from
  CODEX_WORKSPACE_SYNC    set to 1 to git fetch + patch-apply before building
  CODEX_SKIP_BUILD_DEPS   set to 1 to skip package-manager dependency installs
USAGE
      exit 0
      ;;
    *)
      err "Unknown arg: $1"
      exit 2
      ;;
  esac
done

# Paths
BIN_DIR="$PREFIX/bin"
STATE_DIR="$HOME/.local/share/codex-wrapper"
DIST_DIR="$STATE_DIR/dist"
META_FILE="$STATE_DIR/build-info"
CACHE_BASE="${XDG_CACHE_HOME:-$HOME/.cache}"
WORKSPACE_DIR="${CODEX_WORKSPACE:-}"
SKIP_BUILD_DEPS="${CODEX_SKIP_BUILD_DEPS:-0}"
WORKSPACE_SYNC="${CODEX_WORKSPACE_SYNC:-0}"
WORKSPACE_BUILD_DIR="$CACHE_BASE/codex-workspace-build"
SRC_BASE="$CACHE_BASE/codex-src"
SRC_DIR="$SRC_BASE/codex"
if [[ -n "$WORKSPACE_DIR" ]]; then
  SRC_BASE="$WORKSPACE_BUILD_DIR"
  SRC_DIR="$WORKSPACE_BUILD_DIR"
fi
INSTALL_PATH="$BIN_DIR/codex"

# Utils
need_cmd() { command -v "$1" >/dev/null 2>&1; }
do_sudo() { if [[ $NO_SUDO -eq 0 ]]; then sudo "$@"; else "$@"; fi; }

is_wsl() {
  [[ -r /proc/version ]] && grep -qiE '(microsoft|wsl)' /proc/version
}

detect_pm() {
  if need_cmd dnf5; then
    echo dnf5
  elif need_cmd dnf; then
    echo dnf
  elif need_cmd yum; then
    echo yum
  elif need_cmd apt-get; then
    echo apt
  elif need_cmd pacman; then
    echo pacman
  elif need_cmd zypper; then
    echo zypper
  elif need_cmd apk; then
    echo apk
  elif need_cmd brew; then
    echo brew
  else
    echo unknown
  fi
}

install_build_deps() {
  if [[ "$SKIP_BUILD_DEPS" == "1" ]]; then
    log "Skipping system dependency installation (CODEX_SKIP_BUILD_DEPS=1)."
    return 0
  fi
  local pm
  pm="$(detect_pm)"
  log "Detected package manager: $pm"

  case "$pm" in
    dnf5 | dnf)
      do_sudo "$pm" -y groupinstall "Development Tools" || true
      do_sudo "$pm" -y install gcc gcc-c++ make clang pkgconf openssl-devel git curl ca-certificates || true
      ;;
    yum)
      do_sudo yum -y groupinstall "Development Tools" || true
      do_sudo yum -y install gcc gcc-c++ make clang pkgconf openssl-devel git curl ca-certificates || true
      ;;
    apt)
      do_sudo apt-get update -y
      do_sudo apt-get install -y build-essential clang pkg-config libssl-dev git curl ca-certificates
      do_sudo update-ca-certificates || true
      ;;
    pacman)
      do_sudo pacman -Sy --noconfirm --needed base-devel clang pkgconf openssl git curl ca-certificates
      ;;
    zypper)
      do_sudo zypper refresh
      do_sudo zypper -n install -t pattern devel_basis || true
      do_sudo zypper -n install gcc gcc-c++ make clang pkgconf-pkg-config libopenssl-devel git curl ca-certificates
      ;;
    apk)
      do_sudo apk add --no-cache build-base pkgconfig openssl-dev zlib-dev git curl ca-certificates
      ;;
    brew)
      brew install llvm openssl@3 pkg-config git || true
      ;;
    *)
      warn "Unknown package manager; ensure gcc/clang, make, pkg-config, OpenSSL dev, git, and curl are installed."
      ;;
  esac

  if is_wsl; then
    log "WSL detected; proceeding with Linux bootstrap as usual."
  fi
}

ensure_rust() {
  if need_cmd cargo && need_cmd rustc; then
    log "Rust toolchain: $(rustc --version)"
  else
    log "Installing Rust via rustup (non-interactive)"
    curl -sSf https://sh.rustup.rs | sh -s -- -y
    # shellcheck disable=SC1091
    source "$HOME/.cargo/env"
  fi
  rustup toolchain install stable >/dev/null 2>&1 || true
  rustup default stable >/dev/null 2>&1 || true
  log "Using cargo: $(cargo --version)"
}

ensure_paths() {
  mkdir -p "$BIN_DIR" "$SRC_BASE"
  case ":$PATH:" in
    *":$BIN_DIR:"*) ;;
    *) warn "Prefix bin ($BIN_DIR) not in PATH; add: export PATH=\"$BIN_DIR:$PATH\"" ;;
  esac
}

set_profile_var_default() {
  local key="$1"
  local value="$2"
  local var="CARGO_PROFILE_RELEASE_${key}"
  local current="${!var:-}"
  if [[ -z "$current" ]]; then
    export "$var=$value"
    log "Profile override: release.${key,,}=$value"
  else
    log "Profile override preserved: release.${key,,}=$current"
  fi
}

append_rustflags() {
  local addition="$1"
  [[ -z "$addition" ]] && return 0
  if [[ -z "${RUSTFLAGS:-}" ]]; then
    export RUSTFLAGS="$addition"
  else
    export RUSTFLAGS="$RUSTFLAGS $addition"
  fi
}

configure_opt_flags() {
  local preset="${OPT_PRESET,,}"
  set_profile_var_default INCREMENTAL false
  case "$preset" in
    portable)
      set_profile_var_default LTO false
      set_profile_var_default CODEGEN_UNITS 12
      set_profile_var_default STRIP symbols
      set_profile_var_default PANIC unwind
      ;;
    balanced | "")
      set_profile_var_default LTO thin
      set_profile_var_default CODEGEN_UNITS 4
      set_profile_var_default STRIP symbols
      set_profile_var_default PANIC unwind
      ;;
    native)
      local cpu="${TARGET_CPU_OVERRIDE:-native}"
      set_profile_var_default LTO thin
      set_profile_var_default CODEGEN_UNITS 1
      set_profile_var_default STRIP symbols
      set_profile_var_default PANIC abort
      append_rustflags "-C target-cpu=$cpu"
      ;;
    *)
      warn "Unknown optimization preset '$OPT_PRESET'; skipping profile tweaks."
      ;;
  esac

  if [[ -n "$TARGET_CPU_OVERRIDE" && "$preset" != native ]]; then
    append_rustflags "-C target-cpu=$TARGET_CPU_OVERRIDE"
  fi

  append_rustflags "$EXTRA_RUSTFLAGS"

  if [[ -n "$CARGO_JOBS" ]]; then
    export CARGO_BUILD_JOBS="$CARGO_JOBS"
    log "CARGO_BUILD_JOBS=$CARGO_BUILD_JOBS"
  fi

  if [[ -n "${RUSTFLAGS:-}" ]]; then
    log "RUSTFLAGS=$RUSTFLAGS"
  fi
}

configure_sccache() {
  local mode="${USE_SCCACHE,,}"
  case "$mode" in
    on | auto | "")
      if need_cmd sccache; then
        export RUSTC_WRAPPER="sccache"
        export SCCACHE_IDLE_TIMEOUT="${SCCACHE_IDLE_TIMEOUT:-1200}"
        log "Using sccache wrapper (mode=${mode:-auto})"
      elif [[ "$mode" == "on" ]]; then
        warn "CODEX_USE_SCCACHE=on but sccache not found on PATH."
      else
        log "sccache not found; continuing without compiler cache."
      fi
      ;;
    off) ;;
    *)
      warn "Unknown sccache mode '$USE_SCCACHE'; skipping."
      ;;
  esac
}

configure_build_tweaks() {
  configure_sccache
  configure_opt_flags
}

ensure_state_dirs() {
  mkdir -p "$STATE_DIR" "$DIST_DIR"
}

backup_existing() {
  if [[ -x "$INSTALL_PATH" ]]; then
    local ts backup
    ts="$(date +%Y%m%d-%H%M%S)"
    backup="${INSTALL_PATH}.${ts}.bak"
    log "Existing binary detected → backup: $backup"
    cp -f "$INSTALL_PATH" "$backup"
  fi
}

resolve_cc_cxx() {
  local cc_cur="${CC:-}" cxx_cur="${CXX:-}"
  local cc="" cxx=""

  if [[ -n "$CC_OVERRIDE" ]]; then
    cc="$CC_OVERRIDE"
  elif [[ -n "$cc_cur" ]] && need_cmd "$cc_cur"; then
    cc="$cc_cur"
  elif need_cmd gcc; then
    cc="gcc"
  elif need_cmd clang; then
    cc="clang"
  fi

  if [[ -n "$CXX_OVERRIDE" ]]; then
    cxx="$CXX_OVERRIDE"
  elif [[ -n "$cxx_cur" ]] && need_cmd "$cxx_cur"; then
    cxx="$cxx_cur"
  elif need_cmd g++; then
    cxx="g++"
  elif need_cmd clang++; then
    cxx="clang++"
  fi

  if [[ -z "$cc" ]]; then
    err "No working C compiler found (checked CC env, gcc, clang)."
    exit 1
  fi
  export CC="$cc"
  [[ -n "$cxx" ]] && export CXX="$cxx"
  log "C toolchain → CC=${CC}${CXX:+ CXX=${CXX}}"
}

prepare_workspace_repo() {
  local root="$WORKSPACE_DIR"
  local vendor="$root/vendor/codex"

  if [[ ! -d "$root" ]]; then
    err "Workspace directory $root not found (set CODEX_WORKSPACE to a valid codex-updater checkout)."
    exit 1
  fi
  if [[ ! -d "$vendor" ]]; then
    err "Workspace missing vendor/codex (run git submodule update --init --recursive)."
    exit 1
  fi

  if ((WORKSPACE_SYNC)); then
    log "Syncing workspace $root (git fetch + patch apply)"
    (cd "$root" && git fetch origin --tags --prune >/dev/null 2>&1 && git pull --rebase --autostash) ||
      warn "Workspace git pull failed; continuing with local state."
    git -C "$root" submodule update --init --recursive >/dev/null 2>&1 ||
      warn "Failed to update submodules inside workspace."
    if [[ -x "$root/scripts/patch-apply.sh" ]]; then
      (cd "$root" && ./scripts/patch-apply.sh >/dev/null) ||
        warn "patch-apply.sh reported an error; workspace may be inconsistent."
    fi
  else
    log "Using workspace $root without auto-sync (CODEX_WORKSPACE_SYNC=0)."
  fi

  need_cmd rsync
  mkdir -p "$WORKSPACE_BUILD_DIR"
  log "Mirroring $vendor → $WORKSPACE_BUILD_DIR"
  rsync -a --delete --exclude target "$vendor/" "$WORKSPACE_BUILD_DIR"/
  local submodule_git
  submodule_git="$(git -C "$vendor" rev-parse --git-dir 2>/dev/null || true)"
  if [[ -n "$submodule_git" && -d "$submodule_git" ]]; then
    rm -rf "$WORKSPACE_BUILD_DIR/.git"
    rsync -a --delete "$submodule_git/" "$WORKSPACE_BUILD_DIR/.git/"
    python3 - "$WORKSPACE_BUILD_DIR" <<'PY'
import sys
from pathlib import Path

root = Path(sys.argv[1])
cfg = root / ".git" / "config"
if not cfg.exists():
    sys.exit(0)

original = cfg.read_text()
lines = original.splitlines()
updated = []
replaced = False
for line in lines:
    stripped = line.strip()
    if stripped.startswith("worktree"):
        indent = line[: len(line) - len(line.lstrip())]
        updated.append(f"{indent}worktree = {root.as_posix()}")
        replaced = True
    else:
        updated.append(line)
if not replaced:
    updated.append(f"\tworktree = {root.as_posix()}")
cfg.write_text("\n".join(updated) + ("\n" if original.endswith("\n") else ""))
PY
    git --git-dir "$WORKSPACE_BUILD_DIR/.git" config core.worktree "$WORKSPACE_BUILD_DIR" >/dev/null 2>&1 || true
  fi
  SRC_DIR="$WORKSPACE_BUILD_DIR"
}

fetch_repo() {
  mkdir -p "$SRC_BASE"
  if [[ ! -d "$SRC_DIR/.git" ]]; then
    log "Cloning $REPO_URL → $SRC_DIR"
    git clone --depth 1 --branch "$BRANCH" "$REPO_URL" "$SRC_DIR"
  else
    log "Updating repository at $SRC_DIR"
    (cd "$SRC_DIR" && git fetch origin --tags --prune && git checkout "$BRANCH" && git pull --rebase --autostash)
  fi

  if [[ -f "$SRC_DIR/.git/shallow" ]]; then
    log "Repository is shallow; fetching full history for versioning"
    (cd "$SRC_DIR" && git fetch --unshallow >/dev/null 2>&1) || true
  fi

  if ! (cd "$SRC_DIR" && git fetch origin --tags --force --prune >/dev/null 2>&1); then
    warn "Unable to refresh git tags for $REPO_URL (version stamping may fallback to commit time)."
  fi
}

compute_build_version() {
  local root="$1" head short desc base commits commit_id commit_ts fallback version dirty_sig=""
  head="$(git -C "$root" rev-parse HEAD 2>/dev/null || true)"
  short="${head:0:12}"

  if ! git -C "$root" diff --quiet HEAD -- 2>/dev/null ||
    ! git -C "$root" diff --quiet --cached HEAD -- 2>/dev/null; then
    dirty_sig="$(git -C "$root" status --porcelain 2>/dev/null | sha256sum | cut -c1-8 2>/dev/null || true)"
  fi

  if desc="$(git -C "$root" describe --tags --match 'rust-v*' --long 2>/dev/null)" ||
    desc="$(git -C "$root" describe --tags --long 2>/dev/null)"; then
    if [[ "$desc" =~ ^(.+)-([0-9]+)-g([0-9a-f]+)$ ]]; then
      base="${BASH_REMATCH[1]}"
      commits="${BASH_REMATCH[2]}"
      commit_id="${BASH_REMATCH[3]}"
      base="${base#rust-v}"
      base="${base#v}"
      if [[ "${commits}" == "0" ]]; then
        version="$base"
      else
        version="$base+${commits}.${commit_id:-$short}"
      fi
      if [[ -n "$dirty_sig" ]]; then
        version="${version}.dirty${dirty_sig}"
      fi
      printf '%s' "$version"
      return 0
    fi
  fi

  commit_ts="$(git -C "$root" show -s --format=%ct HEAD 2>/dev/null || true)"
  if [[ -n "$commit_ts" ]]; then
    fallback="$(
      python3 - "$commit_ts" <<'PY' 2>/dev/null | tr -d '\n' || true
import sys
from datetime import datetime, timezone

if len(sys.argv) < 2:
    sys.exit(1)

ts = float(sys.argv[1])
dt = datetime.fromtimestamp(ts, tz=timezone.utc)
print(dt.strftime("%Y.%m%d.%H%M"))
PY
    )"
  fi

  if [[ -z "$fallback" ]]; then
    fallback="0.0.0"
  fi
  if [[ -n "$short" ]]; then
    fallback="${fallback}+${short}"
  fi
  if [[ -n "$dirty_sig" ]]; then
    fallback="${fallback}.dirty${dirty_sig}"
  fi
  printf '%s' "$fallback"
}

set_workspace_version() {
  local workspace_root="${1:-}"
  local new_version="${2:-}"
  local cargo_file

  if [[ -z "$workspace_root" ]]; then
    err "Workspace root missing when setting version."
    return 1
  fi
  cargo_file="$workspace_root/Cargo.toml"
  if [[ ! -f "$cargo_file" ]]; then
    err "Cargo workspace manifest not found at $cargo_file"
    return 1
  fi
  if [[ -z "$new_version" ]]; then
    warn "Workspace version not provided; defaulting to 0.0.0"
    new_version="0.0.0"
  fi
  NEW_VERSION="$new_version" python3 - "$cargo_file" <<'PY'
import os, sys
from pathlib import Path
path = Path(sys.argv[1])
version = os.environ["NEW_VERSION"]
original = path.read_text()
lines = original.splitlines()
updated = []
in_ws = False
replaced = False
for line in lines:
    stripped = line.strip()
    if stripped.startswith("["):
        in_ws = stripped == "[workspace.package]"
    if in_ws and stripped.startswith("version"):
        indent = line[: len(line) - len(line.lstrip())]
        updated.append(f'{indent}version = "{version}"')
        replaced = True
        in_ws = False
        continue
    updated.append(line)
if not replaced:
    print("Failed to update workspace version in Cargo.toml", file=sys.stderr)
    sys.exit(1)
path.write_text("\n".join(updated) + ("\n" if original.endswith("\n") else ""))
PY
}

dist_path_for_commit() {
  local commit="$1"
  local safe="${commit//[^A-Za-z0-9._-]/-}"
  printf '%s' "$DIST_DIR/codex-$safe"
}

write_metadata() {
  local commit="$1" version="$2"
  ensure_state_dirs
  {
    printf 'commit=%s\n' "$commit"
    printf 'version=%s\n' "$version"
    printf 'built_at=%s\n' "$(date +%s)"
    printf 'branch=%s\n' "$BRANCH"
    printf 'repo=%s\n' "$REPO_URL"
  } >"$META_FILE"
}

read_metadata() {
  PREV_COMMIT=""
  PREV_VERSION=""
  [[ -f "$META_FILE" ]] || return 1
  while IFS='=' read -r k v; do
    case "$k" in
      commit) PREV_COMMIT="$v" ;;
      version) PREV_VERSION="$v" ;;
    esac
  done <"$META_FILE"
  [[ -n "${PREV_COMMIT:-}" || -n "${PREV_VERSION:-}" ]]
}

build_and_install() {
  local build_dir git_root head_commit build_commit short_commit version dist_target bin_candidate dirty_sig=""
  if [[ -d "$SRC_DIR/codex-rs" ]]; then build_dir="$SRC_DIR/codex-rs"; else build_dir="$SRC_DIR"; fi
  git_root="$SRC_DIR"

  ensure_state_dirs
  read_metadata || true

  head_commit="$(git -C "$git_root" rev-parse HEAD)"
  [[ -n "$head_commit" ]] || {
    err "Unable to determine current commit hash."
    exit 1
  }
  build_commit="$head_commit"
  if ! git -C "$git_root" diff --quiet HEAD -- 2>/dev/null ||
    ! git -C "$git_root" diff --quiet --cached HEAD -- 2>/dev/null; then
    dirty_sig="$(git -C "$git_root" status --porcelain 2>/dev/null | sha256sum | cut -c1-8 2>/dev/null || true)"
    build_commit="${head_commit}-dirty-${dirty_sig}"
  fi
  short_commit="${build_commit:0:12}"
  version="$(compute_build_version "$git_root")"
  dist_target="$(dist_path_for_commit "$build_commit")"

  if [[ $FORCE_REBUILD -ne 1 && "${PREV_COMMIT:-}" == "$build_commit" ]]; then
    if [[ -x "$INSTALL_PATH" ]]; then
      log "No upstream changes (commit $short_commit); reusing existing binary."
      write_metadata "$build_commit" "${PREV_VERSION:-$version}"
      [[ -x "$dist_target" ]] || install -Dm0755 "$INSTALL_PATH" "$dist_target"
      ln -sfn "$dist_target" "$DIST_DIR/latest"
      return 0
    elif [[ -x "$dist_target" ]]; then
      log "Binary missing but cached artifact exists for commit $short_commit; reinstalling."
      backup_existing
      install -Dm0755 "$dist_target" "$INSTALL_PATH"
      write_metadata "$build_commit" "${PREV_VERSION:-$version}"
      ln -sfn "$dist_target" "$DIST_DIR/latest"
      return 0
    else
      log "Commit unchanged but install missing; rebuilding."
    fi
  fi

  log "Building commit $short_commit (version $version) in: $build_dir"
  (
    set -euo pipefail
    cd "$build_dir"
    set_workspace_version "$build_dir" "$version"
    trap 'git checkout -- Cargo.toml Cargo.lock >/dev/null 2>&1 || true' EXIT
    if [[ $FORCE_REBUILD -eq 1 ]]; then
      cargo clean || true
    fi
    cargo fetch --locked >/dev/null 2>&1 || true
    cargo build --release
  )

  bin_candidate="$(find "$build_dir/target/release" -maxdepth 1 -type f -executable -name 'codex' | head -n1 || true)"
  [[ -n "$bin_candidate" ]] || {
    err "Build succeeded but 'codex' binary not found. Check workspace layout."
    exit 1
  }

  install -Dm0755 "$bin_candidate" "$dist_target"
  ln -sfn "$dist_target" "$DIST_DIR/latest"
  backup_existing
  install -Dm0755 "$dist_target" "$INSTALL_PATH"
  write_metadata "$build_commit" "$version"
  log "Installed → $INSTALL_PATH (commit $short_commit, version $version)"
}

verify() {
  if [[ -x "$INSTALL_PATH" ]]; then
    log "Version: $($INSTALL_PATH --version || echo 'unknown')"
    if "$INSTALL_PATH" --help >/dev/null 2>&1; then
      log "Self-test: OK"
    else
      warn "Self-test: FAIL (binary exists but --help errored)."
    fi
  else
    err "Install not found at $INSTALL_PATH"
    exit 1
  fi
}

report_path_conflicts() {
  log "PATH resolution for 'codex':"
  if command -v codex >/dev/null 2>&1; then
    command -v codex
  fi
  if command -v which >/dev/null 2>&1; then which -a codex || true; fi
}

main() {
  log "Starting installer (repo=$REPO_URL, branch=$BRANCH, prefix=$PREFIX)"
  install_build_deps
  ensure_rust
  ensure_paths
  configure_build_tweaks
  resolve_cc_cxx
  if [[ -n "$WORKSPACE_DIR" ]]; then
    prepare_workspace_repo
  else
    fetch_repo
  fi
  build_and_install
  verify
  report_path_conflicts
  log "Done."
}

main "$@"
